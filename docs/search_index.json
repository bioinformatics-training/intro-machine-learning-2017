[
["index.html", "An Introduction to Machine Learning 1 About the course 1.1 Overview 1.2 Registration 1.3 Prerequisites 1.4 Github 1.5 License 1.6 Contact 1.7 Colophon", " An Introduction to Machine Learning Sudhakaran Prabakaran, Matt Wayland and Chris Penfold 2017-09-08 1 About the course 1.1 Overview Machine learning gives computers the ability to learn without being explicitly programmed. It encompasses a broad range of approaches to data analysis with applicability across the biological sciences. Lectures will introduce commonly used algorithms and provide insight into their theoretical underpinnings. In the practicals students will apply these algorithms to real biological data-sets using the R language and environment. During this course you will learn about: Some of the core mathematical concepts underpinning machine learning algorithms: matrices and linear algebra; Bayes’ theorem. Classification (supervised learning): partitioning data into training and test sets; feature selection; logistic regression; support vector machines; artificial neural networks; decision trees; nearest neighbours, cross-validation. Exploratory data analysis (unsupervised learning): dimensionality reduction, anomaly detection, clustering. After this course you should be able to: Understand the concepts of machine learning. Understand the strengths and limitations of the various machine learning algorithms presented in this course. Select appropriate machine learning methods for your data. Perform machine learning in R. 1.2 Registration Bioinformatics Training: An Introduction to Machine Learning 1.3 Prerequisites Some familiarity with R would be helpful. For an introduction to R see An Introduction to Solving Biological Problems with R course. 1.4 Github bioinformatics-training/intro-machine-learning 1.5 License GPL-3 1.6 Contact If you have any comments, questions or suggestions about the material, please contact the authors: Sudhakaran Prabakaran, Matt Wayland and Chris Penfold. 1.7 Colophon This book was produced using the bookdown package (Xie 2017), which was built on top of R Markdown and knitr (Xie 2015). References "],
["intro.html", "2 Introduction", " 2 Introduction You can label chapter and section titles using {#label} after them, e.g., we can reference Chapter 2. If you do not manually label them, there will be automatic labels anyway, e.g., Chapter ??. Figures and tables with captions will be placed in figure and table environments, respectively. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 2.1: Here is a nice figure! Reference a figure by its code chunk label with the fig: prefix, e.g., see Figure 2.1. Similarly, you can reference tables generated from knitr::kable(), e.g., see Table 2.1. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 2.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa "],
["linear-models.html", "3 Linear models and matrix algebra 3.1 Exercises", " 3 Linear models and matrix algebra 3.1 Exercises Solutions to exercises can be found in appendix B "],
["logistic-regression.html", "4 Linear and non linear logistic regression 4.1 Exercises", " 4 Linear and non linear logistic regression 4.1 Exercises Solutions to exercises can be found in appendix C. "],
["nearest-neighbours.html", "5 Nearest neighbours 5.1 Example one 5.2 Example two 5.3 Exercises", " 5 Nearest neighbours Parallel processing with doMC registerDoMC() getDoParWorkers() 5.1 Example one 5.2 Example two 5.3 Exercises Solutions to exercises can be found in appendix D. "],
["decision-trees.html", "6 Decision trees and random forests 6.1 Exercises", " 6 Decision trees and random forests 6.1 Exercises Solutions to exercises can be found in appendix E. "],
["svm.html", "7 Support vector machines 7.1 Exercises", " 7 Support vector machines 7.1 Exercises Solutions to exercises can be found in appendix F "],
["ann.html", "8 Artificial neural networks 8.1 Exercises", " 8 Artificial neural networks 8.1 Exercises Solutions to exercises can be found in appendix G. "],
["dimensionality-reduction.html", "9 Dimensionality reduction 9.1 Linear Dimensionality Reduction 9.2 Nonlinear Dimensionality Reduction 9.3 Exercises", " 9 Dimensionality reduction 9.1 Linear Dimensionality Reduction 9.1.1 Principle Component Analysis 9.1.2 Horeshoe effect 9.2 Nonlinear Dimensionality Reduction 9.2.1 t-SNE 9.2.2 Gaussian Process Latent Variable Models 9.2.3 GPLVMs with informative priors 9.3 Exercises Solutions to exercises can be found in appendix H. "],
["clustering.html", "10 Clustering 10.1 Introduction 10.2 Distance metrics 10.3 Hierarchic agglomerative 10.4 K-means 10.5 DBSCAN 10.6 Summary 10.7 Evaluating cluster quality 10.8 Exercises", " 10 Clustering 10.1 Introduction What is clustering - add figure showing idea of minimizing intra-cluster variation and maximizing inter-cluster variation. Hierarchic (produce dendrogram) vs partitioning methods Hierarchic agglomerative k-means DBSCAN Figure 10.1: Example clusters. A, blobs; B, aggregation (Gionis, Mannila, and Tsaparas 2007); C, noisy moons; D, different density; E, anisotropic distributions; F, no structure. 10.2 Distance metrics dist function cor as.dist(1-cor(x)) Minkowski distance: \\[\\begin{equation} distance\\left(x,y,p\\right)=\\left(\\sum_{i=1}^{n} abs(x_i-y_i)^p\\right)^{1/p} \\tag{10.1} \\end{equation}\\] Graphical explanation of euclidean, manhattan and max (Chebyshev?) 10.2.1 Image segmentation 10.3 Hierarchic agglomerative Figure 10.2: Building a dendrogram using hierarchic agglomerative clustering. Get to see clusters for all number of clusters k 10.3.1 Linkage algorithms Table 10.1: Example distance matrix A B C D B 2 C 6 5 D 10 10 5 E 9 8 3 4 Single linkage - nearest neighbours linkage Complete linkage - furthest neighbours linkage Average linkage - UPGMA (Unweighted Pair Group Method with Arithmetic Mean) Table 10.2: Merge distances for objects in the example distance matrix using three different linkage methods. Groups Single Complete Average A,B,C,D,E 0 0 0 (A,B),C,D,E 2 2 2 (A,B),(C,E),D 3 3 3 (A,B)(C,D,E) 4 5 4.5 (A,B,C,D,E) 5 10 8 Figure 10.3: Dendrograms for the example distance matrix using three different linkage methods. 10.3.2 Example: clustering synthetic data sets 10.3.2.1 Step-by-step instructions Load required packages. library(RColorBrewer) library(dendextend) ## ## --------------------- ## Welcome to dendextend version 1.5.2 ## Type citation(&#39;dendextend&#39;) for how to cite the package. ## ## Type browseVignettes(package = &#39;dendextend&#39;) for the package vignette. ## The github page is: https://github.com/talgalili/dendextend/ ## ## Suggestions and bug-reports can be submitted at: https://github.com/talgalili/dendextend/issues ## Or contact: &lt;tal.galili@gmail.com&gt; ## ## To suppress this message use: suppressPackageStartupMessages(library(dendextend)) ## --------------------- ## ## Attaching package: &#39;dendextend&#39; ## The following object is masked from &#39;package:ggdendro&#39;: ## ## theme_dendro ## The following object is masked from &#39;package:stats&#39;: ## ## cutree library(ggplot2) library(GGally) Retrieve a palette of eight colours. cluster_colours &lt;- brewer.pal(8,&quot;Dark2&quot;) Read in data for blobs example. blobs &lt;- read.csv(&quot;data/example_clusters/blobs.csv&quot;, header=F) Create distance matrix using Euclidean distance metric. d &lt;- dist(blobs[,1:2]) Perform hierarchical clustering using the average agglomeration method and convert the result to an object of class dendrogram. A dendrogram object can be edited using the advanced features of the dendextend package. dend &lt;- as.dendrogram(hclust(d, method=&quot;average&quot;)) Cut the tree into three clusters clusters &lt;- cutree(dend,3,order_clusters_as_data=F) The vector clusters contains the cluster membership (in this case 1, 2 or 3) of each observation (data point) in the order they appear on the dendrogram. We can use this vector to colour the branches of the dendrogram by cluster. dend &lt;- color_branches(dend, clusters=clusters, col=cluster_colours[1:3]) We can use the labels function to annotate the leaves of the dendrogram. However, it is not possible to create legible labels for the 1,500 leaves in our example dendrogram, so we will set the label for each leaf to an empty string. labels(dend) &lt;- rep(&quot;&quot;, length(blobs[,1])) If we want to plot the dendrogram using ggplot, we must convert it to an object of class ggdend. ggd &lt;- as.ggdend(dend) The nodes attribute of ggd is a data.frame of parameters related to the plotting of dendogram nodes. The nodes data.frame contains some NAs which will generate warning messages when ggd is processed by ggplot. Since we are not interested in annotating dendrogram nodes, the easiest option here is to delete all of the rows of nodes. ggd$nodes &lt;- ggd$nodes[!(1:length(ggd$nodes[,1])),] We can use the cluster membership of each observation contained in the vector clusters to assign colours to the data points of a scatterplot. However, first we need to reorder the vector so that the cluster memberships are in the same order that the observations appear in the data.frame of observations. Fortunately the names of the elements of the vector are the indices of the observations in the data.frame and so reordering can be accomplished in one line. clusters &lt;- clusters[order(as.numeric(names(clusters)))] We are now ready to plot a dendrogram and scatterplot. We will use the ggmatrix function from the GGally package to place the plots side-by-side. plotList &lt;- list(ggplot(ggd), ggplot(blobs, aes(V1,V2)) + geom_point(col=cluster_colours[clusters], size=0.2) ) pm &lt;- ggmatrix( plotList, nrow=1, ncol=2, showXAxisPlotLabels = F, showYAxisPlotLabels = F, xAxisLabels=c(&quot;dendrogram&quot;, &quot;scatter plot&quot;) ) + theme_bw() pm Figure 10.4: Hierarchical clustering of the blobs data set. 10.3.2.2 Clustering of other synthetic data sets aggregation &lt;- read.table(&quot;data/example_clusters/aggregation.txt&quot;) noisy_moons &lt;- read.csv(&quot;data/example_clusters/noisy_moons.csv&quot;, header=F) diff_density &lt;- read.csv(&quot;data/example_clusters/different_density.csv&quot;, header=F) aniso &lt;- read.csv(&quot;data/example_clusters/aniso.csv&quot;, header=F) no_structure &lt;- read.csv(&quot;data/example_clusters/no_structure.csv&quot;, header=F) hclust_plots &lt;- function(data_set, n){ d &lt;- dist(data_set[,1:2]) dend &lt;- as.dendrogram(hclust(d, method=&quot;average&quot;)) clusters &lt;- cutree(dend,n,order_clusters_as_data=F) dend &lt;- color_branches(dend, clusters=clusters, col=cluster_colours[1:n]) clusters &lt;- clusters[order(as.numeric(names(clusters)))] labels(dend) &lt;- rep(&quot;&quot;, length(data_set[,1])) ggd &lt;- as.ggdend(dend) ggd$nodes &lt;- ggd$nodes[!(1:length(ggd$nodes[,1])),] plotPair &lt;- list(ggplot(ggd), ggplot(data_set, aes(V1,V2)) + geom_point(col=cluster_colours[clusters], size=0.2)) return(plotPair) } plotList &lt;- c( hclust_plots(aggregation, 7), hclust_plots(noisy_moons, 2), hclust_plots(diff_density, 2), hclust_plots(aniso, 3), hclust_plots(no_structure, 3) ) pm &lt;- ggmatrix( plotList, nrow=5, ncol=2, showXAxisPlotLabels = F, showYAxisPlotLabels = F, xAxisLabels=c(&quot;dendrogram&quot;, &quot;scatter plot&quot;), yAxisLabels=c(&quot;aggregation&quot;, &quot;noisy moons&quot;, &quot;different density&quot;, &quot;anisotropic&quot;, &quot;no structure&quot;) ) + theme_bw() pm Figure 10.5: Hierarchical clustering of synthetic data-sets. 10.3.3 Example: gene expression profiling of human tissues 10.3.3.1 Basics Load required libraries library(RColorBrewer) library(dendextend) Load data load(&quot;data/tissues_gene_expression/tissuesGeneExpression.rda&quot;) Inspect data table(tissue) ## tissue ## cerebellum colon endometrium hippocampus kidney liver ## 38 34 15 31 39 26 ## placenta ## 6 dim(e) ## [1] 22215 189 Compute distance between each sample d &lt;- dist(t(e)) perform hierarchical clustering hc &lt;- hclust(d, method=&quot;average&quot;) plot(hc, labels=tissue, cex=0.5, hang=-1, xlab=&quot;&quot;, sub=&quot;&quot;) Figure 10.6: Clustering of tissue samples based on gene expression profiles. 10.3.3.2 Colour labels use dendextend library to plot dendrogram with colour labels tissue_type &lt;- unique(tissue) dend &lt;- as.dendrogram(hc) dend_colours &lt;- brewer.pal(length(unique(tissue)),&quot;Dark2&quot;) names(dend_colours) &lt;- tissue_type labels(dend) &lt;- tissue[order.dendrogram(dend)] labels_colors(dend) &lt;- dend_colours[tissue][order.dendrogram(dend)] labels_cex(dend) = 0.5 plot(dend, horiz=T) Figure 10.7: Clustering of tissue samples based on gene expression profiles with labels coloured by tissue type. 10.3.3.3 Defining clusters by cutting tree Define clusters by cutting tree at a specific height plot(dend, horiz=T) abline(v=125, lwd=2, lty=2, col=&quot;blue&quot;) Figure 10.8: Clusters found by cutting tree at a height of 125 hclusters &lt;- cutree(dend, h=125) table(tissue, cluster=hclusters) ## cluster ## tissue 1 2 3 4 5 6 ## cerebellum 0 36 0 0 2 0 ## colon 0 0 34 0 0 0 ## endometrium 15 0 0 0 0 0 ## hippocampus 0 31 0 0 0 0 ## kidney 37 0 0 0 2 0 ## liver 0 0 0 24 2 0 ## placenta 0 0 0 0 0 6 Select a specific number of clusters. plot(dend, horiz=T) abline(v = heights_per_k.dendrogram(dend)[&quot;8&quot;], lwd = 2, lty = 2, col = &quot;blue&quot;) Figure 10.9: Selection of eight clusters from the dendogram hclusters &lt;- cutree(dend, k=8) table(tissue, cluster=hclusters) ## cluster ## tissue 1 2 3 4 5 6 7 8 ## cerebellum 0 31 0 0 2 0 5 0 ## colon 0 0 34 0 0 0 0 0 ## endometrium 0 0 0 0 0 15 0 0 ## hippocampus 0 31 0 0 0 0 0 0 ## kidney 37 0 0 0 2 0 0 0 ## liver 0 0 0 24 2 0 0 0 ## placenta 0 0 0 0 0 0 0 6 10.3.3.4 Heatmap Base R provides a heatmap function, but we will use the more advanced heatmap.2 from the gplots package. library(gplots) ## ## Attaching package: &#39;gplots&#39; ## The following object is masked from &#39;package:stats&#39;: ## ## lowess Define a colour palette (also known as a lookup table). heatmap_colours &lt;- colorRampPalette(brewer.pal(9, &quot;PuBuGn&quot;))(100) Calculate the variance of each gene. geneVariance &lt;- apply(e,1,var) Find the row numbers of the 40 genes with the highest variance. idxTop40 &lt;- order(-geneVariance)[1:40] Define colours for tissues. tissueColours &lt;- palette(brewer.pal(8, &quot;Dark2&quot;))[as.numeric(as.factor(tissue))] Plot heatmap. heatmap.2(e[idxTop40,], labCol=tissue, trace=&quot;none&quot;, ColSideColors=tissueColours, col=heatmap_colours) Figure 10.10: Heatmap of the expression of the 40 genes with the highest variance. 10.4 K-means 10.4.1 Algorithm Pseudocode to illustrate range of different types of data that can be clustered - image segmentation Figure 10.11: Iterations of the k-means algorithm The default setting of the kmeans function is to perform a maximum of 10 iterations and if the algorithm fails to converge a warning is issued. The maximum number of iterations is set with the argument iter.max. 10.4.2 Choosing initial cluster centres library(RColorBrewer) point_shapes &lt;- c(15,17,19) point_colours &lt;- brewer.pal(3,&quot;Dark2&quot;) point_size = 1.5 center_point_size = 8 blobs &lt;- as.data.frame(read.csv(&quot;data/example_clusters/blobs.csv&quot;, header=F)) good_centres &lt;- as.data.frame(matrix(c(2,8,7,3,12,7), ncol=2, byrow=T)) bad_centres &lt;- as.data.frame(matrix(c(13,13,8,12,2,2), ncol=2, byrow=T)) good_result &lt;- kmeans(blobs[,1:2], centers=good_centres) bad_result &lt;- kmeans(blobs[,1:2], centers=bad_centres) plotList &lt;- list( ggplot(blobs, aes(V1,V2)) + geom_point(col=point_colours[good_result$cluster], shape=point_shapes[good_result$cluster], size=point_size) + geom_point(data=good_centres, aes(V1,V2), shape=3, col=&quot;black&quot;, size=center_point_size) + theme_bw(), ggplot(blobs, aes(V1,V2)) + geom_point(col=point_colours[bad_result$cluster], shape=point_shapes[bad_result$cluster], size=point_size) + geom_point(data=bad_centres, aes(V1,V2), shape=3, col=&quot;black&quot;, size=center_point_size) + theme_bw() ) pm &lt;- ggmatrix( plotList, nrow=1, ncol=2, showXAxisPlotLabels = T, showYAxisPlotLabels = T, xAxisLabels=c(&quot;A&quot;, &quot;B&quot;) ) + theme_bw() pm Figure 10.12: Initial centres determine clusters. The starting centres are shown as crosses. A, real clusters found; B, convergence to a local minimum. Convergence to a local minimum can be avoided by starting the algorithm multiple times, with different random centres. The nstart argument to the k-means function can be used to specify the number of random sets and optimal solution will be selected automatically. 10.4.3 Choosing k point_colours &lt;- brewer.pal(9,&quot;Set1&quot;) k &lt;- 1:9 res &lt;- lapply(k, function(i){kmeans(blobs[,1:2], i, nstart=50)}) plotList &lt;- lapply(k, function(i){ ggplot(blobs, aes(V1, V2)) + geom_point(col=point_colours[res[[i]]$cluster], size=1) + geom_point(data=as.data.frame(res[[i]]$centers), aes(V1,V2), shape=3, col=&quot;black&quot;, size=5) + annotate(&quot;text&quot;, x=2, y=13, label=paste(&quot;k=&quot;, i, sep=&quot;&quot;), size=8, col=&quot;black&quot;) + theme_bw() } ) pm &lt;- ggmatrix( plotList, nrow=3, ncol=3, showXAxisPlotLabels = T, showYAxisPlotLabels = T ) + theme_bw() pm Figure 10.13: K-means clustering of the blobs data set using a range of values of k from 1-9. Cluster centres indicated with a cross. tot_withinss &lt;- sapply(k, function(i){res[[i]]$tot.withinss}) qplot(k, tot_withinss, geom=c(&quot;point&quot;, &quot;line&quot;), ylab=&quot;Total within-cluster sum of squares&quot;) + theme_bw() Figure 10.14: Variance within the clusters. Total within-cluster sum of squares plotted against k. N.B. we have set nstart=50 to run the algorithm 50 times, starting from different, random sets of centroids. 10.4.4 Example: clustering synthetic data sets Let’s see how k-means performs on the other toy data sets. First we will define some variables and functions we will use in the analysis of all data sets. k=1:9 point_shapes &lt;- c(15,17,19,5,6,0,1) point_colours &lt;- brewer.pal(7,&quot;Dark2&quot;) point_size = 1.5 center_point_size = 8 plot_tot_withinss &lt;- function(kmeans_output){ tot_withinss &lt;- sapply(k, function(i){kmeans_output[[i]]$tot.withinss}) qplot(k, tot_withinss, geom=c(&quot;point&quot;, &quot;line&quot;), ylab=&quot;Total within-cluster sum of squares&quot;) + theme_bw() } plot_clusters &lt;- function(data_set, kmeans_output, num_clusters){ ggplot(data_set, aes(V1,V2)) + geom_point(col=point_colours[kmeans_output[[num_clusters]]$cluster], shape=point_shapes[kmeans_output[[num_clusters]]$cluster], size=point_size) + geom_point(data=as.data.frame(kmeans_output[[num_clusters]]$centers), aes(V1,V2), shape=3,col=&quot;black&quot;,size=center_point_size) + theme_bw() } 10.4.4.1 Aggregation aggregation &lt;- as.data.frame(read.table(&quot;data/example_clusters/aggregation.txt&quot;)) res &lt;- lapply(k, function(i){kmeans(aggregation[,1:2], i, nstart=50)}) plot_tot_withinss(res) Figure 10.15: K-means clustering of the aggregation data set: variance within clusters. plotList &lt;- list( plot_clusters(aggregation, res, 3), plot_clusters(aggregation, res, 7) ) pm &lt;- ggmatrix( plotList, nrow=1, ncol=2, showXAxisPlotLabels = T, showYAxisPlotLabels = T, xAxisLabels=c(&quot;k=3&quot;, &quot;k=7&quot;) ) + theme_bw() pm Figure 10.16: K-means clustering of the aggregation data set: scatterplots of clusters for k=3 and k=7. Cluster centres indicated with a cross. 10.4.4.2 Noisy moons noisy_moons &lt;- read.csv(&quot;data/example_clusters/noisy_moons.csv&quot;, header=F) res &lt;- lapply(k, function(i){kmeans(noisy_moons[,1:2], i, nstart=50)}) plot_tot_withinss(res) Figure 10.17: K-means clustering of the noisy moons data set: variance within clusters. plot_clusters(noisy_moons, res, 2) Figure 10.18: K-means clustering of the noisy moons data set: scatterplot of clusters for k=2. Cluster centres indicated with a cross. 10.4.4.3 Different density diff_density &lt;- as.data.frame(read.csv(&quot;data/example_clusters/different_density.csv&quot;, header=F)) res &lt;- lapply(k, function(i){kmeans(diff_density[,1:2], i, nstart=50)}) ## Warning: did not converge in 10 iterations ## Warning: did not converge in 10 iterations ## Warning: did not converge in 10 iterations ## Warning: did not converge in 10 iterations plot_tot_withinss(res) Figure 10.19: K-means clustering of the different density distributions data set: variance within clusters. plot_clusters(diff_density, res, 2) Figure 10.20: K-means clustering of the different density distributions data set: scatterplots of clusters for k=2 and k=3. Cluster centres indicated with a cross. 10.4.4.4 Anisotropic distributions aniso &lt;- as.data.frame(read.csv(&quot;data/example_clusters/aniso.csv&quot;, header=F)) res &lt;- lapply(k, function(i){kmeans(aniso[,1:2], i, nstart=50)}) plot_tot_withinss(res) Figure 10.21: K-means clustering of the anisotropic distributions data set: variance within clusters. plotList &lt;- list( plot_clusters(aniso, res, 2), plot_clusters(aniso, res, 3) ) pm &lt;- ggmatrix( plotList, nrow=1, ncol=2, showXAxisPlotLabels = T, showYAxisPlotLabels = T, xAxisLabels=c(&quot;k=2&quot;, &quot;k=3&quot;) ) + theme_bw() pm Figure 10.22: K-means clustering of the anisotropic distributions data set: scatterplots of clusters for k=2 and k=3. Cluster centres indicated with a cross. 10.4.4.5 No structure no_structure &lt;- as.data.frame(read.csv(&quot;data/example_clusters/no_structure.csv&quot;, header=F)) res &lt;- lapply(k, function(i){kmeans(no_structure[,1:2], i, nstart=50)}) plot_tot_withinss(res) Figure 10.23: K-means clustering of the data set with no structure: variance within clusters. plot_clusters(no_structure, res, 4) Figure 10.24: K-means clustering of the data set with no structure: scatterplot of clusters for k=4. Cluster centres indicated with a cross. 10.4.5 Example: gene expression profiling of human tissues Let’s return to the data on gene expression of human tissues. Load data load(&quot;data/tissues_gene_expression/tissuesGeneExpression.rda&quot;) As we saw earlier, the data set contains expression levels for over 22,000 transcripts in seven tissues. table(tissue) ## tissue ## cerebellum colon endometrium hippocampus kidney liver ## 38 34 15 31 39 26 ## placenta ## 6 dim(e) ## [1] 22215 189 First we will examine the total intra-cluster variance with different values of k. In practice we would set nstart to a large value (e.g. 50), but in the interests of speed for this demonstration we will set it to one. We use set.seed to make this example reproducible, but in practice we would allow R to generate a random seed. First we will examine the total intra-cluster variance with different values of k. Our data-set is fairly large, so clustering it for several values or k and with multiple random starting centres is computationally quite intensive. Fortunately the task readily lends itself to parallelization; we can assign the analysis of each ‘k’ to a different processing core. As we have seen in the previous chapters on supervised learning, caret has parallel processing built in and we simply have to load a package for multicore processing, such as doMC, and then register the number of cores we would like to use. Running kmeans in parallel is slightly more involved, but still very easy. We will start by loading doMC and registering all available cores: library(doMC) ## Loading required package: foreach ## Loading required package: iterators ## Loading required package: parallel registerDoMC() To find out how many cores we have registered we can use: getDoParWorkers() ## [1] 2 Instead of using the lapply function to vectorize our code, we will instead use the parallel equivalent, foreach. Like lapply, foreach returns a list by default. For this example we have set a seed, rather than generate a random number, for the sake of reproducibility. Ordinarily we would omit set.seed(42) and .options.multicore=list(set.seed=FALSE). k&lt;-1:15 set.seed(42) res_k_15 &lt;- foreach( i=k, .options.multicore=list(set.seed=FALSE)) %dopar% kmeans(t(e), i, nstart=10) plot_tot_withinss(res_k_15) Figure 10.25: K-means clustering of human tissue gene expression: variance within clusters. There is no obvious elbow, but the rate of decrease in the total-within sum of squares appears to slow after k=5. Since we know that there are seven tissues in the data set we will try k=7. set.seed(42) res &lt;- kmeans(t(e), 7, nstart=10) table(tissue, res$cluster) ## ## tissue 1 2 3 4 5 6 7 ## cerebellum 0 0 0 33 0 0 5 ## colon 0 0 0 0 0 34 0 ## endometrium 0 0 0 0 15 0 0 ## hippocampus 0 0 0 0 0 0 31 ## kidney 0 0 39 0 0 0 0 ## liver 26 0 0 0 0 0 0 ## placenta 0 6 0 0 0 0 0 The analysis has found a distinct cluster for each tissue and therefore performed slightly better than the earlier hierarchical clustering analysis, which placed endometrium and kidney observations in the same cluster. To visualize the result in a 2D scatter plot we first need to apply dimensionality reduction. We will use principal component analysis (PCA), which was described in chapter 9. pca &lt;- prcomp(t(e)) ggplot(data=as.data.frame(pca$x), aes(PC1,PC2)) + geom_point(col=brewer.pal(7,&quot;Dark2&quot;)[res$cluster], shape=c(49:55)[res$cluster], size=5) + theme_bw() Figure 10.26: K-means clustering of human gene expression (k=7): scatterplot of first two principal components. 10.5 DBSCAN Density-based spatial clustering of applications with noise 10.5.1 Algorithm Abstract DBSCAN algorithm in pseudocode (Schubert et al. 2017) 1 Compute neighbours of each point and identify core points // Identify core points 2 Join neighbouring core points into clusters // Assign core points 3 foreach non-core point do Add to a neighbouring core point if possible // Assign border points Otherwise, add to noise // Assign noise points Figure 10.27: Illustration of the DBSCAN algorithm. 10.5.2 Choosing parameters The algorithm only needs parameteres eps and minPts. library(dbscan) blobs &lt;- read.csv(&quot;data/example_clusters/blobs.csv&quot;, header=F) dist2knn &lt;- kNNdist(blobs, 10) kNNdistplot(blobs[,1:2], k=10) res &lt;- dbscan::dbscan 10.5.3 Example: clustering synthetic data sets 10.5.3.1 Aggregation 10.5.3.2 Noisy moons 10.5.3.3 Different density 10.5.3.4 Anisotropic distributions 10.5.3.5 No structure 10.5.4 Example: gene expression profiling of human tissues tissue types? 10.6 Summary 10.6.1 Applications 10.6.2 Strengths 10.6.3 Limitations 10.7 Evaluating cluster quality 10.8 Exercises Exercise solutions: I Solutions to exercises can be found in appendix I. References "],
["resources.html", "A Resources A.1 Python A.2 Machine learning data set repositories", " A Resources A.1 Python scikit-learn A.2 Machine learning data set repositories A.2.1 MLDATA mldata.org This repository manages the following types of objects: Data Sets - Raw data as a collection of similarily structured objects. Material and Methods - Descriptions of the computational pipeline. Learning Tasks - Learning tasks defined on raw data. Challenges - Collections of tasks which have a particular theme. A.2.2 UCI Machine Learning Repository Machine learning database at the University of California, Irvine, School of Information and Computer Sciences (Lichman 2013). References "],
["solutions-linear-models.html", "B Solutions ch. 3 - Linear models and matrix algebra B.1 Exercise 1 B.2 Exercise 2", " B Solutions ch. 3 - Linear models and matrix algebra Solutions to exercises of chapter 3. B.1 Exercise 1 B.2 Exercise 2 "],
["solutions-logistic-regression.html", "C Solutions ch. 4 - Linear and non-linear logistic regression C.1 Exercise 1 C.2 Exercise 2", " C Solutions ch. 4 - Linear and non-linear logistic regression Solutions to exercises of chapter 4. C.1 Exercise 1 C.2 Exercise 2 "],
["solutions-nearest-neighbours.html", "D Solutions ch. 5 - Nearest neighbours D.1 Exercise 1 D.2 Exercise 2", " D Solutions ch. 5 - Nearest neighbours Solutions to exercises of chapter 5. D.1 Exercise 1 D.2 Exercise 2 "],
["solutions-decision-trees.html", "E Solutions ch. 6 - Decision trees and random forests E.1 Exercise 1 E.2 Exercise 2", " E Solutions ch. 6 - Decision trees and random forests Solutions to exercises of chapter 6. E.1 Exercise 1 E.2 Exercise 2 "],
["solutions-svm.html", "F Solutions ch. 7 - Support vector machines F.1 Exercise 1 F.2 Exercise 2", " F Solutions ch. 7 - Support vector machines Solutions to exercises of chapter 7. F.1 Exercise 1 F.2 Exercise 2 "],
["solutions-ann.html", "G Solutions ch. 8 - Artificial neural networks G.1 Exercise 1 G.2 Exercise 2", " G Solutions ch. 8 - Artificial neural networks Solutions to exercises of chapter 8. G.1 Exercise 1 G.2 Exercise 2 "],
["solutions-dimensionality-reduction.html", "H Solutions ch. 9 - Dimensionality reduction H.1 Exercise 1 H.2 Exercise 2", " H Solutions ch. 9 - Dimensionality reduction Solutions to exercises of chapter 9. H.1 Exercise 1 H.2 Exercise 2 "],
["solutions-clustering.html", "I Solutions ch. 10 - Clustering I.1 Exercise 1 I.2 Exercise 2", " I Solutions ch. 10 - Clustering Solutions to exercises of chapter 10. I.1 Exercise 1 I.2 Exercise 2 "],
["references.html", "References", " References "]
]
